# -*- coding: utf-8 -*-
# @Author: Justus Multhaup
# @Date:   2023-01-16 09:52:02
# @Last Modified by:   Your name
# @Last Modified time: 2023-01-26 10:19:59


##Simple routine to optimize boundary densities by polytype conversion
##Uses example input files generated by SOMA

import h5py
import numpy as np
import matplotlib.pyplot as plt
from copy import deepcopy
import random


######################## LOAD DATA ETC ##########################

##coord data
with h5py.File('coord.h5', 'r') as f:
    ##number of beads per polymer
    N=int(f['parameter/reference_Nbeads'][()]) 
    ##number of polymers and types
    n_polym=int(f['parameter/n_polymers'][()]) 
    n_poly_type=int(f['parameter/n_poly_type'][()]) 
    ##box dimensions 
    lxyz=np.array(f['parameter/lxyz'])
    ##box discretization
    nxyz=np.array(f['parameter/nxyz'])
    nx=nxyz[0]
    ny=nxyz[1]
    nz=nxyz[2]
    ##umbrella field (target density)
    phi_target=np.array(f['umbrella_field'])
    ##polymer types
    poly_types=np.array(f['poly_type'])




##field scaling factor
scale=np.prod(nxyz)/(N*n_polym)

#read density field from density_field.txt
phi=np.loadtxt("density_field.txt")
phi=phi.reshape(n_poly_type,nx,ny,nz)

##read polymer info
file = open('poly_info.txt', 'r')
lines = file.readlines()

##polymers that may be flipped
flip_candidates_type=[]
##cells that flip candidates have monomers in
flip_candidates_cells=[]
##how many monomers are in that cell
flip_candidates_num=[]



k=0
for line in lines:
    int_list = [int(i) for i in line.split()]
    if k == 0:
        flip_candidates_type.append(int_list)
        k+=1
    elif k == 1:
        flip_candidates_cells.append(int_list)
        k+=1
    else:
        k=0
        flip_candidates_num.append(int_list)

flip_candidates_type = [item for sublist in flip_candidates_type for item in sublist]

def cost(phi,delta_phi,phi_target):
    """cost function to be minimized

    Args:
        phi (list): density field
        phi_target (list): Target density field. Only values > 0 are regarded

    Returns:
        float: squared deviation from target density summed over cells and types
    """
    
    """     total_cost=0
    for i in range(n_poly_type):
        for x in range(nx):
            for y in range(ny):
                for z in range(nz):
                    if phi_target[i,x,y,z]>0:
                        total_cost+=(phi_target[i,x,y,z] - phi[i,x,y,z]-delta_phi[i,x,y,z])**2 """
    total_cost= sum(np.square(phi_target[phi_target > 0] - phi[phi_target > 0]-delta_phi[phi_target > 0] ))
    return total_cost


def flip(poly_type):
    """helper function to flip polymer types

    Args:
        poly_type (int): polymer type
    Returns:
        int: polymer type after flip
    """
    if poly_type == 0:
        return 1
    else:
        return 0



def convert_target1(phi,phi_target,flip_candidates_type,flip_candidates_cells,flip_candidates_num,iter=100):
    """Convert polymers to reach target density. Polymer is flipped if, on average, all the target cells in which it has monomers get closer to their target density. Parallelization not possible.

    Args:
        phi (float array): Initial density field.
        phi_target (float array): Target density field. Only values > 0 are regarded
        flip_candidates_type (int array): Polytypes of flip candidates.
        flip_candidates_cells (int array): Cell indices of flip candidates.
        flip_candidates_num (int array): Number of monomers corresponding to cell indices.
        iter (int, optional): Number of iterations. Defaults to 100.

    Returns:
        float: Total cost.
        float array: Change in density field.
    """
    delta_phi=np.zeros_like(phi)
    ##loop over polymers
    for k in range(iter):
        for poly in range(len(flip_candidates_type)):
            initial_type=flip_candidates_type[poly]
            final_type=flip(initial_type)
            diff=0
            diff_flip=0
            ##calculate deviations from target density in cells that polymer has monomers in and check if a flip is a good idea
            for j in range(len(flip_candidates_cells[poly])):
                x,y,z=np.unravel_index(flip_candidates_cells[poly][j], (nx,ny,nz))
                for type in range(n_poly_type):
                    diff+=(phi_target[type,x,y,z]-phi[type,x,y,z]-delta_phi[type,x,y,z] )**2
                diff_flip+=(phi_target[initial_type,x,y,z]-phi[initial_type,x,y,z]-delta_phi[initial_type,x,y,z] +flip_candidates_num[poly][j] * scale)**2
                diff_flip+=(phi_target[final_type,x,y,z]-phi[final_type,x,y,z] - delta_phi[final_type,x,y,z] -flip_candidates_num[poly][j] * scale)**2
            if diff_flip < diff:
                ##flip polymer and update density fields
                flip_candidates_type[poly]=final_type
                for j in range(len(flip_candidates_cells[poly])):
                    x,y,z=np.unravel_index(flip_candidates_cells[poly][j], (nx,ny,nz))
                    delta_phi[initial_type,x,y,z]-=flip_candidates_num[poly][j] * scale
                    delta_phi[final_type,x,y,z]+=flip_candidates_num[poly][j] * scale
    total_cost=cost(phi,delta_phi,phi_target)
    return total_cost, delta_phi


def convert_target2(phi,flip_candidates_type,flip_candidates_cells,flip_candidates_num,iter=10000,Tmin=0.0001,Tmax=1,alpha=0.85):
    delta_phi=np.zeros_like(phi)
    delta_phi_old=delta_phi
    delta_phi_best=delta_phi
    total_cost=cost(phi, delta_phi, phi_target)  
    total_cost_old=total_cost  
    total_cost_best=total_cost
    poly_types=flip_candidates_type
    poly_types_old=poly_types
    poly_types_best=poly_types
    flip_prob=1/len(flip_candidates_type)
    print(flip_prob)
    for i in range(iter):
        """
        rejected_flips = 0
        while(rejected_flips < 100):
            for poly in range(len(flip_candidates_type)):
                random_number=random.random()
                if random_number < flip_prob:
                    initial_type=poly_types[poly]
                    final_type=flip(initial_type)
                    poly_types[poly]=final_type
                    ##update delta_phi
                    for j in range(len(flip_candidates_cells[poly])):
                        x,y,z=np.unravel_index(flip_candidates_cells[poly][j], (nx,ny,nz))
                        delta_phi[initial_type,x,y,z] -= flip_candidates_num[poly][j] * scale
                        delta_phi[final_type,x,y,z] += flip_candidates_num[poly][j] * scale
            total_cost=cost(phi,delta_phi,phi_target)
            if total_cost<total_cost_old:
                poly_types_old=poly_types
                delta_phi_old=delta_phi
                total_cost_old=total_cost
            else:
                poly_types=poly_types_old
                delta_phi=delta_phi_old
                total_cost=total_cost_old
                rejected_flips += 1
        """
        ## do some simulated annealing by swapping poly types
        #print(flip_prob)
        T=Tmax
        while(T > Tmin):
            for poly in range(len(flip_candidates_type)):
                random_number=random.random()
                if random_number < flip_prob:
                    initial_type=poly_types[poly]
                    final_type=flip(initial_type)
                    poly_types[poly]=final_type
                    ##update delta_phi
                    for j in range(len(flip_candidates_cells[poly])):
                        x,y,z=np.unravel_index(flip_candidates_cells[poly][j], (nx,ny,nz))
                        delta_phi[initial_type,x,y,z] -= flip_candidates_num[poly][j] * scale
                        delta_phi[final_type,x,y,z] += flip_candidates_num[poly][j] * scale
            total_cost=cost(phi,delta_phi,phi_target)
            if total_cost<total_cost_old:
                poly_types_old=poly_types
                delta_phi_old=delta_phi
                total_cost_old=total_cost
            else:
                acc_prob = np.exp(-(total_cost - total_cost_old)/T)
                random_number=random.random()
                if random_number < acc_prob:
                    poly_types_old=poly_types
                    delta_phi_old=delta_phi
                    total_cost_old=total_cost
                else:
                    poly_types=poly_types_old
                    delta_phi=delta_phi_old
                    total_cost=total_cost_old
                
            ##update best solution
            if total_cost < total_cost_best:
                poly_types_best=poly_types
                delta_phi_best=delta_phi
                total_cost_best=total_cost

            T *= alpha
        poly_types=poly_types_best
        delta_phi=delta_phi_best
        total_cost=total_cost_best
        print(total_cost_best)

    return total_cost_best , delta_phi


def convert_target3(phi,flip_candidates_type,flip_candidates_cells,flip_candidates_num,iter=10,Tmin=0.0001,Tmax=1,alpha=0.85):
    """Choose random polymer in each annealing step and flip it. 

    Args:
        phi (_type_): _description_
        flip_candidates_type (_type_): _description_
        flip_candidates_cells (_type_): _description_
        flip_candidates_num (_type_): _description_
        iter (int, optional): _description_. Defaults to 10.
        Tmin (float, optional): _description_. Defaults to 0.0001.
        Tmax (int, optional): _description_. Defaults to 1.
        alpha (float, optional): _description_. Defaults to 0.85.

    Returns:
        _type_: _description_
    """
    delta_phi=np.zeros_like(phi)
    delta_phi=np.zeros_like(phi)
    delta_phi_old=delta_phi
    delta_phi_best=delta_phi
    total_cost=cost(phi, delta_phi, phi_target)  
    total_cost_old=total_cost  
    total_cost_best=total_cost
    poly_types=flip_candidates_type
    poly_types_old=poly_types
    poly_types_best=poly_types
    ##loop over polymers
    for k in range(iter):
        T=Tmax
        while(T>Tmin):
            poly=np.random.randint(len(flip_candidates_type))
            initial_type=poly_types[poly]
            final_type=flip(initial_type)
            diff=0
            diff_flip=0
            ##calculate deviations from target density in cells that polymer has monomers in and check if a flip is a good idea
            for j in range(len(flip_candidates_cells[poly])):
                x,y,z=np.unravel_index(flip_candidates_cells[poly][j], (nx,ny,nz))
                for type in range(n_poly_type):
                    diff+=(phi_target[type,x,y,z]-phi[type,x,y,z]-delta_phi[type,x,y,z] )**2
                diff_flip+=(phi_target[initial_type,x,y,z]-phi[initial_type,x,y,z]-delta_phi[initial_type,x,y,z] +flip_candidates_num[poly][j] * scale)**2
                diff_flip+=(phi_target[final_type,x,y,z]-phi[final_type,x,y,z] - delta_phi[final_type,x,y,z] -flip_candidates_num[poly][j] * scale)**2
            if diff_flip < diff:
                ##flip polymer and update density fields
                poly_types[poly]=final_type
                delta_phi_old=delta_phi
                total_cost_old=total_cost
                for j in range(len(flip_candidates_cells[poly])):
                    x,y,z=np.unravel_index(flip_candidates_cells[poly][j], (nx,ny,nz))
                    delta_phi[initial_type,x,y,z]-=flip_candidates_num[poly][j] * scale
                    delta_phi[final_type,x,y,z]+=flip_candidates_num[poly][j] * scale
                    
            else:
                acc_prob = np.exp(-(diff_flip-diff)/T)
                random_number=random.random()
                if random_number < acc_prob:
                    poly_types[poly]=final_type
                    delta_phi_old=delta_phi
                    total_cost_old=total_cost
                else:
                    delta_phi=delta_phi_old
                    total_cost=total_cost_old
                    poly_types[poly]=poly_types_old[poly]
            total_cost=cost(phi,delta_phi,phi_target)
            ##update best solution
            if total_cost < total_cost_best:
                poly_types_best=poly_types
                delta_phi_best=delta_phi
                total_cost_best=total_cost
            T *= alpha
        poly_types=poly_types_best
        delta_phi=delta_phi_best
        total_cost=total_cost_best
    return total_cost, delta_phi


def convert_target4(phi,flip_candidates_type,flip_candidates_cells,flip_candidates_num,Tmin=0.0001,Tmax=1,alpha=0.85,sa_acc_rate_target=0.99,max_sa_runs=1000):
    """Convert polymer types in conversion zone to reach target density. 
       Minimizes cost function by choosing a random polymer in each annealing step and flipping it according to the metropolis hastings criterion.
       Repeat annealing until convergence criterion is reached

    Args:
        phi (_type_): _description_
        flip_candidates_type (_type_): _description_
        flip_candidates_cells (_type_): _description_
        flip_candidates_num (_type_): _description_
        Tmin (float, optional): _description_. Defaults to 0.0001.
        Tmax (int, optional): _description_. Defaults to 1.
        alpha (float, optional): _description_. Defaults to 0.85.

    Returns:
        _type_: _description_
    """
    delta_phi=np.zeros_like(phi)
    delta_phi_best=delta_phi
    total_cost=cost(phi, delta_phi, phi_target)  
    total_cost_old=total_cost
    total_cost_best=total_cost ##best value after sa run
    total_cost_best_old=total_cost ##best value before sa run
    poly_types=flip_candidates_type
    poly_types_best=poly_types
    sa_runs=0 ##count simulated annealing runs
    sa_runs_accepted=0 ##count how many sa runs were accepted
    sa_acc_rate=1 ##sa runs acceptance rate
    cost_arr=np.array([]) ##cost function
    ##loop over polymers
    while(sa_acc_rate > sa_acc_rate_target and sa_runs < max_sa_runs):
        sa_runs+=1
        T=Tmax
        total_cost_best_old=total_cost_best
        while(T>Tmin):
            poly=np.random.randint(len(flip_candidates_type))
            initial_type=poly_types[poly]
            final_type=flip(initial_type)
            total_cost=total_cost_old
            ##calculate cost function (only need to update it for the cells in which the polymer has monomers)
            for j in range(len(flip_candidates_cells[poly])):
                x,y,z=np.unravel_index(flip_candidates_cells[poly][j], (nx,ny,nz))
                for type in range(n_poly_type):
                    ##subtract squared density differences for each type and cell
                    total_cost-=(phi_target[type,x,y,z]-phi[type,x,y,z]-delta_phi[type,x,y,z] )**2
                ##add new values 
                total_cost+=(phi_target[initial_type,x,y,z]-phi[initial_type,x,y,z]-delta_phi[initial_type,x,y,z] +flip_candidates_num[poly][j] * scale)**2
                total_cost+=(phi_target[final_type,x,y,z]-phi[final_type,x,y,z] - delta_phi[final_type,x,y,z] -flip_candidates_num[poly][j] * scale)**2
            
            if total_cost < total_cost_old:
                ##flip polymer and update delta_phi
                poly_types[poly]=final_type
                total_cost_old=total_cost
                for j in range(len(flip_candidates_cells[poly])):
                    x,y,z=np.unravel_index(flip_candidates_cells[poly][j], (nx,ny,nz))
                    delta_phi[initial_type,x,y,z]-=flip_candidates_num[poly][j] * scale
                    delta_phi[final_type,x,y,z]+=flip_candidates_num[poly][j] * scale
                    
            else:
                acc_prob = np.exp(-(total_cost-total_cost_old)/T)
                random_number=random.random()
                if random_number < acc_prob:
                    ##accept
                    poly_types[poly]=final_type
                    total_cost_old=total_cost
                    for j in range(len(flip_candidates_cells[poly])):
                        x,y,z=np.unravel_index(flip_candidates_cells[poly][j], (nx,ny,nz))
                        delta_phi[initial_type,x,y,z]-=flip_candidates_num[poly][j] * scale
                        delta_phi[final_type,x,y,z]+=flip_candidates_num[poly][j] * scale
                else:
                    ##reject
                    total_cost=total_cost_old
            cost_arr=np.append(cost_arr,total_cost)
            ##update best solution
            if total_cost < total_cost_best:
                poly_types_best=poly_types
                delta_phi_best=delta_phi
                total_cost_best=total_cost
            T *= alpha

        if total_cost_best<total_cost_best_old:
            poly_types=poly_types_best
            delta_phi=delta_phi_best
            total_cost=total_cost_best
            sa_runs_accepted+=1
        sa_acc_rate=sa_runs_accepted/sa_runs
        print(sa_acc_rate)
        #print(total_cost)
        #print(total_cost_best)
    return total_cost, delta_phi, cost_arr


#cost_opt, delta_phi = convert_target1(phi,phi_target,flip_candidates_type,flip_candidates_cells,flip_candidates_num)
#cost_opt, delta_phi = convert_target2(phi,flip_candidates_type,flip_candidates_cells,flip_candidates_num,iter=10000,Tmin=0.0001,Tmax=1,alpha=0.85)
#cost_opt, delta_phi = convert_target3(phi,flip_candidates_type,flip_candidates_cells,flip_candidates_num,Tmin=0.001,Tmax=1,alpha=0.85)
cost_opt, delta_phi ,cost_arr = convert_target4(phi,flip_candidates_type,flip_candidates_cells,flip_candidates_num,Tmin=0.0001,Tmax=0.001,alpha=0.85,sa_acc_rate_target=0.6)
phi_opt=phi+delta_phi
print(cost_opt)
t=np.array(range(len(cost_arr)))
plt.plot(t,cost_arr)
plt.show()
#print(phi_opt[0])



