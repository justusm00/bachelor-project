# -*- coding: utf-8 -*-
# @Author: Justus Multhaup
# @Date:   2023-01-16 09:52:02
# @Last Modified by:   Your name
# @Last Modified time: 2023-01-16 12:48:27


##Simple routine to optimize boundary densities by polytype conversion
##Uses example input files generated by SOMA

import h5py
import numpy as np
import matplotlib.pyplot as plt
from copy import deepcopy
import random


######################## LOAD DATA ETC ##########################

##coord data
with h5py.File('coord.h5', 'r') as f:
    ##number of beads per polymer
    N=int(f['parameter/reference_Nbeads'][()]) 
    ##number of polymers and types
    n_polym=int(f['parameter/n_polymers'][()]) 
    n_poly_type=int(f['parameter/n_poly_type'][()]) 
    ##box dimensions 
    lxyz=np.array(f['parameter/lxyz'])
    ##box discretization
    nxyz=np.array(f['parameter/nxyz'])
    nx=nxyz[0]
    ny=nxyz[1]
    nz=nxyz[2]
    ##umbrella field (target density)
    phi_target=np.array(f['umbrella_field'])
    ##polymer types
    poly_types=np.array(f['poly_type'])




##field scaling factor
scale=np.prod(nxyz)/(N*n_polym)

#read density field from density_field.txt
phi=np.loadtxt("density_field.txt")
phi=phi.reshape(n_poly_type,nx,ny,nz)

##read polymer info
file = open('poly_info.txt', 'r')
lines = file.readlines()

##polymers that may be flipped
flip_candidates_type=[]
##cells that flip candidates have monomers in
flip_candidates_cells=[]
##how many monomers are in that cell
flip_candidates_num=[]


k=0
for line in lines:
    int_list = [int(i) for i in line.split()]
    if k == 0:
        flip_candidates_type.append(int_list)
        k+=1
    elif k == 1:
        flip_candidates_cells.append(int_list)
        k+=1
    else:
        k=0
        flip_candidates_num.append(int_list)


def cost(phi,delta_phi,phi_target):
    """cost function to be minimized

    Args:
        phi (list): density field
        phi_target (list): Target density field. Only values > 0 are regarded

    Returns:
        float: squared deviation from target density summed over cells and types
    """
    total_cost= sum(np.square(phi_target[phi_target > 0] - phi[phi_target > 0]-delta_phi[phi_target > 0] ))
    return total_cost


def flip(poly_type):
    """helper function to flip polymer types

    Args:
        poly_type (int): polymer type
    Returns:
        int: polymer type after flip
    """
    if poly_type == 0:
        return 1
    else:
        return 0



def convert_target1(phi,phi_target,flip_candidates_type,flip_candidates_cells,flip_candidates_num,iter=100):
    """Convert polymers to reach target density. Polymer is flipped if, on average, all the target cells in which it has monomers get closer to their target density. Parallelization not possible.

    Args:
        phi (float array): Initial density field.
        phi_target (float array): Target density field. Only values > 0 are regarded
        flip_candidates_type (int array): Polytypes of flip candidates.
        flip_candidates_cells (int array): Cell indices of flip candidates.
        flip_candidates_num (int array): Number of monomers corresponding to cell indices.
        iter (int, optional): Number of iterations. Defaults to 100.

    Returns:
        float: Total cost.
        float array: Change in density field.
    """
    delta_phi=np.zeros_like(phi)
    ##loop over polymers
    for k in range(iter):
        for poly in range(len(flip_candidates_type)):
            initial_type=flip_candidates_type[poly][0]
            final_type=flip(initial_type)
            diff=0
            diff_flip=0
            ##calculate deviations from target density in cells that polymer has monomers in and check if a flip is a good idea
            for j in range(len(flip_candidates_cells[poly])):
                x,y,z=np.unravel_index(flip_candidates_cells[poly][j], (nx,ny,nz))
                for type in range(n_poly_type):
                    diff+=(phi_target[type,x,y,z]-phi[type,x,y,z]-delta_phi[type,x,y,z] )**2
                diff_flip+=(phi_target[initial_type,x,y,z]-phi[initial_type,x,y,z]-delta_phi[initial_type,x,y,z] +flip_candidates_num[poly][j] * scale)**2
                diff_flip+=(phi_target[final_type,x,y,z]-phi[final_type,x,y,z] - delta_phi[final_type,x,y,z] -flip_candidates_num[poly][j] * scale)**2
            if diff_flip < diff:
                ##flip polymer and update density fields
                flip_candidates_type[poly][0]=final_type
                for j in range(len(flip_candidates_cells[poly])):
                    x,y,z=np.unravel_index(flip_candidates_cells[poly][j], (nx,ny,nz))
                    delta_phi[initial_type,x,y,z]-=flip_candidates_num[poly][j] * scale
                    delta_phi[final_type,x,y,z]+=flip_candidates_num[poly][j] * scale
    total_cost=cost(phi,delta_phi,phi_target)
    return total_cost, delta_phi


def convert_target2(phi,flip_candidates_type,flip_candidates_cells,flip_candidates_num,iter=100):
    delta_phi=np.zeros_like(phi)
    delta_phi_old=delta_phi
    delta_phi_best=delta_phi
    total_cost=cost(phi, delta_phi, phi_target)  
    total_cost_old=total_cost  
    total_cost_best=total_cost
    poly_types=flip_candidates_type
    poly_types_old=poly_types
    poly_types_best=poly_types
    flip_prob=1/len(flip_candidates_type)
    for i in range(iter):
        rejected_flips = 0
        while(rejected_flips < 100):
            for poly in range(len(flip_candidates_type)):
                random_number=random.random()
                if random_number < flip_prob:
                    initial_type=poly_types[poly]
                    final_type=flip(initial_type)
                    poly_types[poly]=final_type
                    ##update delta_phi
                    for j in range(len(flip_candidates_cells[poly])):
                        x,y,z=np.unravel_index(flip_candidates_cells[poly][j], (nx,ny,nz))
                        delta_phi[initial_type,x,y,z] -= flip_candidates_num[poly][j] * scale
                        delta_phi[final_type,x,y,z] += flip_candidates_num[poly][j] * scale
            total_cost=cost(phi,delta_phi,phi_target)
            if total_cost<total_cost_old:
                poly_types_old=poly_types
                delta_phi_old=delta_phi
                total_cost_old=total_cost
            else:
                poly_types=poly_types_old
                delta_phi=delta_phi_old
                total_cost=total_cost_old
                rejected_flips += 1
        """
        ## do some simulated annealing
        T=10
        while(T > 0.01):
            for poly in range(len(flip_candidates_type)):
                random_number=random.random()
                if random_number < flip_prob:
                    initial_type=poly_types[poly]
                    final_type=flip(initial_type)
                    poly_types[poly]=final_type
                    ##update delta_phi
                    for j in range(len(flip_candidates_cells[poly])):
                        x,y,z=np.unravel_index(flip_candidates_cells[poly][j], (nx,ny,nz))
                        delta_phi[initial_type,x,y,z] -= flip_candidates_num[poly][j] * scale
                        delta_phi[final_type,x,y,z] += flip_candidates_num[poly][j] * scale
            total_cost=cost(phi,delta_phi,phi_target)
            if total_cost<total_cost_old:
                poly_types_old=poly_types
                delta_phi_old=delta_phi
                total_cost_old=total_cost
            else:
                acc_prob = np.exp(-(total_cost - total_cost_old)/T)
                random_number=random.random()
                if random_number < acc_prob:
                    poly_types_old=poly_types
                    delta_phi_old=delta_phi
                    total_cost_old=total_cost
                else:
                    poly_types=poly_types_old
                    delta_phi=delta_phi_old
                    total_cost=total_cost_old
                
            ##update best solution
            if total_cost < total_cost_best:
                poly_types_best=poly_types
                delta_phi_best=delta_phi
                total_cost_best=total_cost

            T *= 0.85
        poly_types=poly_types_best
        delta_phi=delta_phi_best
        total_cost=total_cost_best
        """
    return total_cost , delta_phi

#cost_opt, delta_phi = convert_target1(phi,phi_target,flip_candidates_type,flip_candidates_cells,flip_candidates_num)
cost_opt, delta_phi = convert_target2(phi,flip_candidates_type,flip_candidates_cells,flip_candidates_num)
phi_opt=phi+delta_phi
print(cost_opt)
print(np.mean(phi_opt, axis=(2,3)))



